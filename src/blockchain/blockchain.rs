use std::collections::HashSet;

use crate::*;

#[derive(Debug)]
pub enum BlockValidationError {
    MissmatchedIndex,
    InvalidHash,
    AchronlogicalTimestamp,
    MismatchedPreviousHash,
    InvalidFirstBlockFormat,
    InvalidInput,
    InsufficientInputValue,
    InvalidCoinbaseTransaction
}


pub struct BlockChain {
    pub blocks: Vec<Block>,
    pub unspent_outputs: HashSet<BlockHash>,
}

impl BlockChain {

    pub fn new () -> Self {
        BlockChain {
            blocks: vec![],
            unspent_outputs: HashSet::new(),
        }
    }

    pub fn update_with_block(&mut self, block: Block) -> Result<(), BlockValidationError> {
        let i = self.blocks.len();
        let mut total_fee: u64 = 0;
    
        if block.index != i as u32 {
            return Err(BlockValidationError::MissmatchedIndex);
        } else if !check_difficulty(&block.hash(), block.difficulty) {
            return Err(BlockValidationError::InvalidHash);
        } else if i == 0 {
            if block.prev_block_hash != vec![0; 32] {
                return Err(BlockValidationError::InvalidFirstBlockFormat);
            }
        } else {
            let prev_block = &self.blocks[i - 1];
            if block.timestamp < prev_block.timestamp {
                return Err(BlockValidationError::AchronlogicalTimestamp);
            } else if block.prev_block_hash != prev_block.hash {
                return Err(BlockValidationError::MismatchedPreviousHash);
            }
        }
    
        // splitting transactions vector by first block
        if let Some((coinbase, transactions)) = block.transactions.split_first() {
            if !coinbase.is_coinbase() {
                println!("{}", coinbase.inputs.len());
                return Err(BlockValidationError::InvalidCoinbaseTransaction);
            }
            let mut block_spent = HashSet::<BlockHash>::new();
            let mut block_created = HashSet::<BlockHash>::new();
    
            for transaction in transactions {
                let input_hashes = transaction.input_hashes();
    
                // every input hash in unspent outputs?
                // empty input hashes
                if !(&input_hashes - &self.unspent_outputs).is_empty() || 
                   !(&input_hashes & &block_spent).is_empty() {
                    return Err(BlockValidationError::InvalidInput);
                }
    
                let input_value = transaction.input_value();
                let output_value = transaction.output_value();
                if output_value >= input_value {
                    return Err(BlockValidationError::InsufficientInputValue);
                }
    
                // fee for miners
                let fee = input_value - output_value;
                total_fee += fee;
    
                // add the hashes of transaction to block_spent
                block_spent.extend(input_hashes);
                block_created.extend(transaction.output_hashes());
            }
            if coinbase.output_value() < total_fee {
                // more validation like right amount generated by coinbase?
                return Err(BlockValidationError::InvalidCoinbaseTransaction);
            } else {
                block_created.extend(coinbase.output_hashes());
            }
    
            self.unspent_outputs.retain(|output| !block_spent.contains(output)); // remove all that has been spent
            self.unspent_outputs.extend(block_created);
        }
    
        // after passing all the validation tests, im adding block to the blockchain
        self.blocks.push(block);
        // println!("{:?}", total_fee);
    
        Ok(())
    }

    pub fn total_unspent(&self) -> u64 {
        self.unspent_outputs
            .iter()
            .map(|hash| {
                self.blocks
                    .iter()
                    .flat_map(|block| &block.transactions)
                    .flat_map(|transaction| &transaction.outputs)
                    // find provided hash in the blockchain
                    .find(|output| &output.hash() == hash)
                    .map_or(0, |output| output.value)
            })
            // sum hashes
            .sum()
    }
    
}

